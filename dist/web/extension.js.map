{"version":3,"file":"extension.js","mappings":"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","sources":["../.././src/web/emacs.ts","../.././src/web/find.ts","../.././src/web/mark.ts","../.././src/web/multi-command.ts","../.././src/web/record.ts","../../external commonjs \"vscode\"","../../webpack/bootstrap","../.././src/web/extension.ts"],"sourcesContent":["import * as vscode from 'vscode';\nimport {Recorder} from './record';\nimport {MarkHandler} from './mark';\nimport {FindHandler} from './find';\nimport {multiCommand} from './multi-command';\n\nconst jumpDist = 10;\nexport const cursorMoves: string[] = [\n  \"cursorUp\", \n  \"cursorDown\",\n  \"cursorLeft\",\n  \"cursorRight\",\n  \"cursorHome\",\n  \"cursorEnd\",\n  \"cursorWordLeft\",\n  \"cursorWordRight\",\n  \"cursorTop\",\n  \"cursorBottom\"\n];\n\nconst ctrlGCommands: string[] = [\n  \"cancelSelection\",\n  \"closeFindWidget\",\n  \"closeParameterHints\",\n  \"removeSecondaryCursors\",\n];\n\nconst deleteLeft = \"deleteLeft\";\nconst deleteRight = \"deleteRight\";\nconst deleteWordLeft = \"deleteWordLeft\";\nconst deleteWordRight = \"deleteWordRight\";\n\nexport const deleteCommands: string[] = [\n  deleteLeft,\n  deleteRight,\n  deleteWordLeft,\n  deleteWordRight,\n];\n\ninterface Registerable {\n  register(context: vscode.ExtensionContext, recorder: Recorder): void;\n}\n\ninterface TypeHandler extends Registerable {  \n  active: boolean;\n  activate(): void;\n  deactivate(): void;\n  ctrlG(): void;\n\n  onYank(text: string | undefined): void\n  alwaysOnYank(): boolean\n  onKill(text: string | undefined): void\n  alwaysOnKill(): boolean\n\n  // Returns whether or not to still send the code\n  textHandler(s: string): boolean;\n  delHandler(cmd: string): boolean;\n  moveHandler(cmd: string, ...rest: any[]): boolean;\n\n  // TODO pasteHandler\n  // TODO escape handler (or just same ctrl g?)\n}\n\nexport class Emacs {\n  private qmk: boolean;\n  recorder: Recorder;\n  typeHandlers: TypeHandler[];\n\n  constructor() {\n    // TODO: store this in persistent storage somewhere\n    this.qmk = false;\n    this.recorder = new Recorder();\n    this.typeHandlers = [\n      new FindHandler(),\n      new MarkHandler(),\n      this.recorder,\n    ];\n  }\n\n  register(context: vscode.ExtensionContext) {\n    for (var move of cursorMoves) {\n      const m = move;\n      this.recorder.registerCommand(context, move, () => this.move(m));\n    }\n    for (var dc of deleteCommands) {\n      const d = dc;\n      this.recorder.registerCommand(context, d, () => this.delCommand(d));\n    }\n\n    context.subscriptions.push(vscode.commands.registerCommand('type', (...args: any[]) => {\n      this.type(...args);\n    }));\n\n    this.recorder.registerCommand(context, 'jump', () => this.jump());\n    this.recorder.registerCommand(context, 'fall', () => this.fall());\n\n    this.recorder.registerCommand(context, 'toggleQMK', () => this.toggleQMK());\n    this.recorder.registerCommand(context, 'yank', () => this.yank());\n    this.recorder.registerCommand(context, 'kill', () => this.kill());\n    this.recorder.registerCommand(context, 'ctrlG', () => this.ctrlG());\n\n    for (var th of this.typeHandlers) {\n      th.register(context, this.recorder);\n    }\n\n    this.recorder.registerCommand(context, \"multiCommand.execute\", multiCommand);\n  }\n\n  runHandlers(thCallback: (th: TypeHandler) => boolean, applyCallback: () => void) {\n    let apply = true;\n    for (var th of this.typeHandlers) {\n      if (th.active) {\n        if (!thCallback(th)) {\n          // Note, we can't do \"apply &&= th.textHandler\" because\n          // if apply is set to false at some point, then later\n          // handlers won't run\n          apply = false;\n        }\n      }\n    }\n    if (apply) {\n      applyCallback();\n    }\n  }\n\n  type(...args: any[]) {\n    if (!vscode.window.activeTextEditor) {\n      vscode.window.showInformationMessage(\"NOT TEXT EDITOR?!?!\");\n\t\t}\n\n    let s = (args[0] as TypeArg).text;\n    this.runHandlers(\n      (th: TypeHandler): boolean => { return th.textHandler(s); },\n      () => {vscode.commands.executeCommand(\"default:type\", ...args);},\n    );\n  }\n\n  delCommand(d: string) {\n    this.runHandlers(\n      (th: TypeHandler): boolean => { return th.delHandler(d); },\n      () => {vscode.commands.executeCommand(d);},\n    );\n  }\n\n  toggleQMK() {\n    if (this.qmk) {\n      vscode.window.showInformationMessage('Basic keyboard mode activated');\n    } else {\n      vscode.window.showInformationMessage('QMK keyboard mode activated');\n    }\n\t\tthis.qmk = !this.qmk;\n    vscode.commands.executeCommand('setContext', 'groog.qmk', this.qmk);\n  }\n\n  yank() {\n    let range = vscode.window.activeTextEditor?.selection;\n    let maybe = vscode.window.activeTextEditor?.document.getText(range);\n    if (maybe) {\n      vscode.window.activeTextEditor?.edit(editBuilder => {\n        if (range) {\n          editBuilder.delete(range);\n        }\n      });\n    }\n\n    for (var th of this.typeHandlers) {\n      if (th.active || th.alwaysOnYank()) {\n        th.onYank(maybe);\n      }\n    }\n  }\n\n  ctrlG() {\n    for (var th of this.typeHandlers) {\n      if (th.active) {\n        th.ctrlG();\n      }\n    }\n    for (var cmd of ctrlGCommands) {\n      vscode.commands.executeCommand(cmd);\n    }\n  }\n\n  kill() {\n    let editor = vscode.window.activeTextEditor;\n    if (!editor) {\n      return;\n    }\n\n    let startPos = editor.selection.active;\n    let endPos = editor.document.lineAt(startPos.line).range.end;\n    let range = new vscode.Range(startPos, endPos);\n    let text = editor.document.getText(range);\n    if (text.trim().length === 0) {\n      range = new vscode.Range(startPos, new vscode.Position(startPos.line + 1, 0));\n    }\n    for (var th of this.typeHandlers) {\n      if (th.active || th.alwaysOnKill()) {\n        th.onKill(text);\n      }\n    }\n    vscode.window.activeTextEditor?.edit(editBuilder => {\n      editBuilder.delete(range);\n    });\n  }\n\n  // C-l\n  jump() {\n    this.move(\"cursorMove\", {\"to\": \"up\", \"by\": \"line\", \"value\": jumpDist});\n  }\n\n  // C-v\n  fall() {\n    this.move(\"cursorMove\", {\"to\": \"down\", \"by\": \"line\", \"value\": jumpDist});\n  }\n\n  move(vsCommand: string, ...rest: any[]) {\n    this.runHandlers(\n      (th: TypeHandler): boolean => { return th.moveHandler(vsCommand, ...rest); },\n      () => {vscode.commands.executeCommand(vsCommand, ...rest);},\n    );\n  }\n}\n\nclass TypeArg {\n  text: string;\n\n  constructor(text: string) {\n    this.text = \"\";\n  }\n}\n","import * as vscode from 'vscode';\nimport {Recorder} from './record';\n\nexport class FindHandler {\n  active: boolean;\n  findText: string;\n  cursorStack: CursorStack;\n\n  constructor() {\n    this.active = false;\n    this.findText = \"\";\n    this.cursorStack = new CursorStack();\n  }\n\n  cursorToFront() {\n    // Move cursor to beginning of selection\n    let editor = vscode.window.activeTextEditor;\n    if (editor) {\n      let startPos = editor.selection.start;\n      editor.selection = new vscode.Selection(startPos, startPos);\n    }\n  }\n\n  nextMatch() {\n    // Then find next match\n    vscode.commands.executeCommand(\"editor.action.nextMatchFindAction\");\n  }\n\n  prevMatch() {\n    vscode.commands.executeCommand(\"editor.action.previousMatchFindAction\");\n  }\n\n  register(context: vscode.ExtensionContext, recorder: Recorder) {\n    // TODO: cache previous find\n    recorder.registerCommand(context, 'find', () => {\n      if (this.active) {\n        this.nextMatch();\n      } else {\n        this.activate();\n      }\n    });\n    recorder.registerCommand(context, 'reverseFind', () => {\n      if (this.active) {\n        this.prevMatch();\n      } else {\n        this.activate();\n      }\n    });\n    vscode.window.onDidChangeActiveTextEditor(() => {\n      this.deactivate();\n    });\n  }\n\n  activate() {\n    this.active = true;\n    vscode.commands.executeCommand('setContext', 'groog.findMode', true);\n    this.findWithArgs();\n  }\n\n  deactivate() {\n    this.active = false;\n    vscode.commands.executeCommand('setContext', 'groog.findMode', false);\n    this.findText = \"\";\n    this.cursorStack.clear();\n    vscode.commands.executeCommand(\"cancelSelection\");\n    vscode.commands.executeCommand(\"closeFindWidget\");\n  }\n\n  findWithArgs() {\n    let txt = this.findText;\n    if (this.findText.length === 0) {\n      txt = \"ENTER\" + \"_TEXT\";\n    }\n    vscode.commands.executeCommand(\"editor.actions.findWithArgs\", {\"searchString\": txt}).then(() => {\n      vscode.commands.executeCommand(\"workbench.action.focusActiveEditorGroup\");\n    }, () => {\n      vscode.commands.executeCommand(\"workbench.action.focusActiveEditorGroup\");\n    }\n    );\n    this.cursorToFront();\n    this.nextMatch();\n  }\n\n  ctrlG() {\n    this.deactivate();\n  }\n\n  textHandler(s: string): boolean {\n    // Enter, shift+enter, ctrl+n, ctrl+p taken care of in package.json\n    this.findText = this.findText.concat(s);\n    this.cursorStack.push();\n    this.findWithArgs();\n    return false;\n  }\n\n  moveHandler(s: string): boolean {\n    this.deactivate();\n    return true;\n  }\n\n  delHandler(s: string): boolean {\n    switch (s) {\n      case \"deleteLeft\":\n        this.findText = this.findText.slice(0, this.findText.length-1);\n        this.cursorStack.popAndSet();\n        this.findWithArgs();\n        break;\n      default:\n        vscode.window.showInformationMessage(\"Unsupported find command: \" + s);\n      }\n    return false;\n  }\n\n  // TODO: do something like error message or deactivate\n  onYank(s: string | undefined) {}\n  alwaysOnYank(): boolean {return false;}\n  onKill(s: string | undefined) {}\n  alwaysOnKill(): boolean {return false;}\n}\n\nclass CursorStack {\n  selections: vscode.Position[];\n\n  constructor() {\n    this.selections = [];\n  }\n\n  push() {\n    let editor = vscode.window.activeTextEditor;\n    if (!editor) {\n      vscode.window.showErrorMessage(\"Couldn't find active editor\");\n      this.selections.push(new vscode.Position(0, 0));\n      return;\n    }\n    this.selections.push(new vscode.Position(editor.selection.start.line, editor.selection.start.character));\n  }\n\n  popAndSet() {\n    let p = this.selections.pop();\n    if (!p) {\n      vscode.window.showErrorMessage(\"Ran out of cursor positions\");\n      return;\n    }\n    let editor = vscode.window.activeTextEditor;\n    if (!editor) {\n      vscode.window.showErrorMessage(\"Undefined editor\");\n      return;\n    }\n    // https://github.com/microsoft/vscode/issues/111#issuecomment-157998910\n    editor.selection = new vscode.Selection(p, p);\n  }\n\n  clear() {\n    this.selections = [];\n  }\n}","import * as vscode from 'vscode';\nimport {Recorder} from './record';\n\nexport class MarkHandler {\n  active: boolean;\n  yanked: string;\n\n  constructor() {\n    this.active = false;\n    this.yanked = \"\";\n  }\n\n  register(context: vscode.ExtensionContext, recorder: Recorder) {\n    recorder.registerCommand(context, 'toggleMarkMode', () => {\n      if (this.active) {\n        this.deactivate();\n      } else {\n        this.activate();\n      }\n    });\n    recorder.registerCommand(context, 'paste', () => {\n      if (this.active) {\n        this.deactivate();\n      }\n\n      vscode.window.activeTextEditor?.edit(editBuilder => {\n        let editor = vscode.window.activeTextEditor;\n        if (!editor) {\n          return;\n        }\n        editBuilder.insert(editor.selection.active, this.yanked);\n      });\n    });\n  }\n\n  activate() {\n    this.active = true;\n    vscode.commands.executeCommand('setContext', 'groog.markMode', true);\n  }\n\n  deactivate() {\n    this.active = false;\n    vscode.commands.executeCommand('setContext', 'groog.markMode', false);\n  }\n\n  ctrlG() {\n    this.deactivate();\n  }\n\n  textHandler(s: string): boolean {\n    this.deactivate();\n    return true;\n  }\n\n  moveHandler(vsCommand: string, ...rest: any[]): boolean {\n    // See below link for cusorMove args (including \"select\" keyword)\n    // https://code.visualstudio.com/api/references/commands\n    if (vsCommand === \"cursorMove\") {\n      rest[0].select = true;\n      vscode.commands.executeCommand(vsCommand, ...rest);\n    } else {\n      vscode.commands.executeCommand(vsCommand + \"Select\", ...rest);\n    }\n    return false;\n  }\n\n  delHandler(s: string): boolean {\n    this.deactivate();\n    return true;\n  }\n\n  onYank(s: string | undefined) {\n    this.deactivate();\n    s ? this.yanked = s : this.yanked = \"\";\n  }\n\n  alwaysOnYank(): boolean {\n    return true;\n  }\n\n  onKill(s: string | undefined) {\n    this.deactivate();\n    s ? this.yanked = s : this.yanked = \"\";\n  }\n\n  alwaysOnKill(): boolean {\n    return true;\n  }\n}","import * as vscode from 'vscode';\n\nexport interface MultiCommand {\n  sequence: string[]\n}\n\nexport function multiCommand(mc: MultiCommand) {\n  for (var command of mc.sequence) {\n    vscode.commands.executeCommand(command);\n  }\n}\n","import * as vscode from 'vscode';\n\nexport class Recorder {\n  private baseCommand: boolean;\n  active: boolean; // aka \"recording\"\n  private recordBook: Record[];\n\n  constructor() {\n    this.baseCommand = true;\n    this.active = false;\n    this.recordBook = [];\n  }\n\n  register(context: vscode.ExtensionContext, recorder: Recorder) {\n    recorder.registerCommand(context, \"record.startRecording\", () => recorder.startRecording());\n    recorder.registerCommand(context, \"record.endRecording\", () => recorder.endRecording());\n    recorder.registerCommand(context, \"record.playRecording\", () => recorder.playback());\n  }\n\n  registerCommand(context: vscode.ExtensionContext, commandName: string, callback: (...args: any[]) => any) {\n    context.subscriptions.push(vscode.commands.registerCommand(\"groog.\" + commandName, (...args: any) => {\n      this.execute(\"groog.\" + commandName, args, callback);\n    }));\n  }\n\n  execute(command: string, args: any[], callback: (...args: any[]) => any): any {\n    if (command.includes(\"groog.record\") || !this.active || !this.baseCommand) {\n      return callback(...args);\n    }\n    this.addRecord(new Record(command, args));\n    this.baseCommand = false;\n    let r = callback(...args);\n    this.baseCommand = true;\n    return r;\n  }\n\n  startRecording() {\n    if (this.active) {\n      vscode.window.showInformationMessage(\"Already recording!\");\n    } else {\n      this.activate();\n      this.recordBook = [];\n      vscode.window.showInformationMessage(\"Recording started!\");\n    }\n  }\n\n  endRecording() {\n    if (!this.active) {\n      vscode.window.showInformationMessage(\"Not recording!\");\n    } else {\n      this.deactivate();\n      vscode.window.showInformationMessage(\"Recording ended!\");\n    }\n  }\n\n  playback() {\n    if (this.active) {\n      vscode.window.showInformationMessage(\"Still recording!\");\n      return;\n    }\n    vscode.window.showInformationMessage(\"Playing recording!\");\n    let sl: string[] = [];\n    for (var record of this.recordBook) {\n      sl.push(record.command);\n      vscode.commands.executeCommand(record.command, ...record.args);\n    }\n  }\n\n  activate() {\n    this.active = true;\n    vscode.commands.executeCommand('setContext', 'groog.recording', true);\n  }\n\n  deactivate() {\n    this.active = false;\n    vscode.commands.executeCommand('setContext', 'groog.recording', false);\n\n  }\n\n  addRecord(r: Record) {\n    this.recordBook = this.recordBook.concat(r);\n  }\n\n  textHandler(s: string): boolean {\n    this.addRecord(new Record(\"type\", [{ \"text\": s}]));\n    return true;\n  }\n  \n  // All these functions are associated with a \"groog.*\" command so these are\n  // already added to the record book via the \"type\" command handling\n  onKill(s: string | undefined) {}\n  alwaysOnKill(): boolean {return false;}\n  ctrlG() {}\n  onYank(s: string | undefined) {}\n  alwaysOnYank(): boolean {return false;}\n  delHandler(s: string): boolean {\n    return true;\n  }\n  moveHandler(vsCommand: string, ...rest: any[]): boolean {\n    return true;\n  }\n}\n\nclass Record {\n  command: string;\n  args: any[];\n\n  constructor(command: string, args: any[]) {\n    this.command = command;\n    this.args = args;\n  }\n}","module.exports = require(\"vscode\");","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// The module 'vscode' contains the VS Code extensibility API\n// Import the module and reference it with the alias vscode in your code below\nimport * as vscode from 'vscode';\nimport {Emacs} from './emacs';\n\nconst groogery = new Emacs();\n\n// this method is called when your extension is activated\n// your extension is activated the very first time the command is executed\nexport function activate(context: vscode.ExtensionContext) {\n  groogery.register(context);\n}\n\n// this method is called when your extension is deactivated\nexport function deactivate() {}\n"],"names":["cursorMoves","ctrlGCommands","deleteCommands","constructor","this","qmk","recorder","Recorder","typeHandlers","FindHandler","MarkHandler","register","context","move","m","registerCommand","dc","d","delCommand","th","subscriptions","push","vscode","commands","args","type","jump","fall","toggleQMK","yank","kill","ctrlG","multiCommand","runHandlers","thCallback","applyCallback","apply","active","window","activeTextEditor","showInformationMessage","s","text","textHandler","executeCommand","delHandler","range","selection","maybe","document","getText","edit","editBuilder","delete","alwaysOnYank","onYank","cmd","editor","startPos","endPos","lineAt","line","end","Range","trim","length","Position","alwaysOnKill","onKill","vsCommand","rest","moveHandler","findText","cursorStack","CursorStack","cursorToFront","start","Selection","nextMatch","prevMatch","activate","onDidChangeActiveTextEditor","deactivate","findWithArgs","clear","txt","then","concat","slice","popAndSet","selections","showErrorMessage","character","p","pop","yanked","insert","select","mc","command","sequence","baseCommand","recordBook","startRecording","endRecording","playback","commandName","callback","execute","includes","addRecord","Record","r","sl","record","module","exports","require","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","__webpack_modules__","groogery","Emacs"],"sourceRoot":""}