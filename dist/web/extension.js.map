{"version":3,"file":"extension.js","mappings":"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","sources":["../.././src/web/emacs.ts","../.././src/web/find.ts","../.././src/web/mark.ts","../.././src/web/multi-command.ts","../.././src/web/record.ts","../../external commonjs \"vscode\"","../../webpack/bootstrap","../.././src/web/extension.ts"],"sourcesContent":["import * as vscode from 'vscode';\nimport { Recorder } from './record';\nimport { MarkHandler } from './mark';\nimport { FindHandler } from './find';\nimport { multiCommand } from './multi-command';\n\nconst jumpDist = 10;\nexport const cursorMoves: string[] = [\n  // Note: if you are receiving an error of the form\n  // `command \"groog.cursorUp\" already exists`, it is probably\n  // because this extension is installed twice. Once as a regular\n  // extension and once as the development extension. Disable\n  // the regular extension to get the correct behavior.\n  \"cursorUp\",\n  \"cursorDown\",\n  \"cursorLeft\",\n  \"cursorRight\",\n  \"cursorHome\",\n  \"cursorEnd\",\n  \"cursorWordLeft\",\n  \"cursorWordRight\",\n  \"cursorTop\",\n  \"cursorBottom\"\n];\n\nconst ctrlGCommands: string[] = [\n  \"cancelSelection\",\n  \"closeFindWidget\",\n  \"closeParameterHints\",\n  \"removeSecondaryCursors\",\n];\n\nconst deleteLeft = \"deleteLeft\";\nconst deleteRight = \"deleteRight\";\nconst deleteWordLeft = \"deleteWordLeft\";\nconst deleteWordRight = \"deleteWordRight\";\n\nexport const deleteCommands: string[] = [\n  deleteLeft,\n  deleteRight,\n  deleteWordLeft,\n  deleteWordRight,\n];\n\ninterface Registerable {\n  register(context: vscode.ExtensionContext, recorder: Recorder): void;\n}\n\ninterface TypeHandler extends Registerable {\n  active: boolean;\n  activate(): void;\n  deactivate(): void;\n  ctrlG(): void;\n\n  onYank(text: string | undefined): void\n  alwaysOnYank(): boolean\n  onKill(text: string | undefined): void\n  alwaysOnKill(): boolean\n\n  // Returns whether or not to still send the code\n  textHandler(s: string): boolean;\n  delHandler(cmd: string): boolean;\n  moveHandler(cmd: string, ...rest: any[]): boolean;\n\n  // TODO pasteHandler\n  // TODO escape handler (or just same ctrl g?)\n}\n\nconst qmkKey = \"groog.keys.qmkState\";\n\nclass GlobalStateTracker<ValueType> {\n  private key: string;\n\n  constructor(key: string) {\n    this.key = key;\n  }\n\n  get(context: vscode.ExtensionContext): ValueType | undefined {\n    return context.globalState.get<ValueType>(this.key);\n  }\n\n  update(context: vscode.ExtensionContext, vt: ValueType) {\n    context.globalState.update(this.key, vt);\n  }\n}\n\nexport class Emacs {\n  private qmk: GlobalStateTracker<boolean>;\n  recorder: Recorder;\n  typeHandlers: TypeHandler[];\n\n  constructor() {\n    this.qmk = new GlobalStateTracker<boolean>(qmkKey);\n    this.recorder = new Recorder();\n    this.typeHandlers = [\n      new FindHandler(),\n      new MarkHandler(),\n      this.recorder,\n    ];\n  }\n\n  register(context: vscode.ExtensionContext) {\n    for (var move of cursorMoves) {\n      const m = move;\n      this.recorder.registerCommand(context, move, () => this.move(m));\n    }\n    for (var dc of deleteCommands) {\n      const d = dc;\n      this.recorder.registerCommand(context, d, () => this.delCommand(d));\n    }\n\n    context.subscriptions.push(vscode.commands.registerCommand('type', (...args: any[]) => {\n      this.type(...args);\n    }));\n\n    this.recorder.registerCommand(context, 'jump', () => this.jump());\n    this.recorder.registerCommand(context, 'fall', () => this.fall());\n\n    this.recorder.registerCommand(context, 'toggleQMK', () => this.toggleQMK(context));\n    this.recorder.registerCommand(context, 'yank', () => this.yank());\n    this.recorder.registerCommand(context, 'kill', () => this.kill());\n    this.recorder.registerCommand(context, 'ctrlG', () => this.ctrlG());\n\n    for (var th of this.typeHandlers) {\n      th.register(context, this.recorder);\n    }\n\n    this.recorder.registerCommand(context, \"multiCommand.execute\", multiCommand);\n\n    // After all commands have been registered, check persistent data for qmk setting.\n    this.setQMK(context, this.qmk.get(context));\n  }\n\n  runHandlers(thCallback: (th: TypeHandler) => boolean, applyCallback: () => void) {\n    let apply = true;\n    for (var th of this.typeHandlers) {\n      if (th.active) {\n        if (!thCallback(th)) {\n          // Note, we can't do \"apply &&= th.textHandler\" because\n          // if apply is set to false at some point, then later\n          // handlers won't run\n          apply = false;\n        }\n      }\n    }\n    if (apply) {\n      applyCallback();\n    }\n  }\n\n  type(...args: any[]) {\n    if (!vscode.window.activeTextEditor) {\n      vscode.window.showInformationMessage(\"NOT TEXT EDITOR?!?!\");\n    }\n\n    let s = (args[0] as TypeArg).text;\n    this.runHandlers(\n      (th: TypeHandler): boolean => { return th.textHandler(s); },\n      () => { vscode.commands.executeCommand(\"default:type\", ...args); },\n    );\n  }\n\n  delCommand(d: string) {\n    this.runHandlers(\n      (th: TypeHandler): boolean => { return th.delHandler(d); },\n      () => { vscode.commands.executeCommand(d); },\n    );\n  }\n\n  toggleQMK(context: vscode.ExtensionContext) {\n    this.setQMK(context, !this.qmk.get(context));\n  }\n\n  setQMK(context: vscode.ExtensionContext, bu: boolean | undefined) {\n    let b = bu || false;\n    if (b) {\n      vscode.window.showInformationMessage('QMK keyboard mode activated');\n    } else {\n      vscode.window.showInformationMessage('Basic keyboard mode activated');\n    }\n    this.qmk.update(context, b);\n    vscode.commands.executeCommand('setContext', 'groog.qmk', b);\n  }\n\n  yank() {\n    let range = vscode.window.activeTextEditor?.selection;\n    let maybe = vscode.window.activeTextEditor?.document.getText(range);\n    if (maybe) {\n      vscode.window.activeTextEditor?.edit(editBuilder => {\n        if (range) {\n          editBuilder.delete(range);\n        }\n      });\n    }\n\n    for (var th of this.typeHandlers) {\n      if (th.active || th.alwaysOnYank()) {\n        th.onYank(maybe);\n      }\n    }\n  }\n\n  ctrlG() {\n    for (var th of this.typeHandlers) {\n      if (th.active) {\n        th.ctrlG();\n      }\n    }\n    for (var cmd of ctrlGCommands) {\n      vscode.commands.executeCommand(cmd);\n    }\n  }\n\n  kill() {\n    let editor = vscode.window.activeTextEditor;\n    if (!editor) {\n      return;\n    }\n\n    let startPos = editor.selection.active;\n    let endPos = editor.document.lineAt(startPos.line).range.end;\n    let range = new vscode.Range(startPos, endPos);\n    let text = editor.document.getText(range);\n    if (text.trim().length === 0) {\n      range = new vscode.Range(startPos, new vscode.Position(startPos.line + 1, 0));\n    }\n    for (var th of this.typeHandlers) {\n      if (th.active || th.alwaysOnKill()) {\n        th.onKill(text);\n      }\n    }\n    vscode.window.activeTextEditor?.edit(editBuilder => {\n      editBuilder.delete(range);\n    });\n  }\n\n  // C-l\n  jump() {\n    this.move(\"cursorMove\", { \"to\": \"up\", \"by\": \"line\", \"value\": jumpDist });\n  }\n\n  // C-v\n  fall() {\n    this.move(\"cursorMove\", { \"to\": \"down\", \"by\": \"line\", \"value\": jumpDist });\n  }\n\n  move(vsCommand: string, ...rest: any[]) {\n    this.runHandlers(\n      (th: TypeHandler): boolean => { return th.moveHandler(vsCommand, ...rest); },\n      () => { vscode.commands.executeCommand(vsCommand, ...rest); },\n    );\n  }\n}\n\nclass TypeArg {\n  text: string;\n\n  constructor(text: string) {\n    this.text = \"\";\n  }\n}\n","import * as vscode from 'vscode';\nimport {Recorder} from './record';\n\nexport class FindHandler {\n  active: boolean;\n  findText: string;\n  cursorStack: CursorStack;\n\n  constructor() {\n    this.active = false;\n    this.findText = \"\";\n    this.cursorStack = new CursorStack();\n  }\n\n  cursorToFront() {\n    // Move cursor to beginning of selection\n    let editor = vscode.window.activeTextEditor;\n    if (editor) {\n      let startPos = editor.selection.start;\n      editor.selection = new vscode.Selection(startPos, startPos);\n    }\n  }\n\n  nextMatch() {\n    // Then find next match\n    vscode.commands.executeCommand(\"editor.action.nextMatchFindAction\");\n  }\n\n  prevMatch() {\n    vscode.commands.executeCommand(\"editor.action.previousMatchFindAction\");\n  }\n\n  register(context: vscode.ExtensionContext, recorder: Recorder) {\n    // TODO: cache previous find\n    recorder.registerCommand(context, 'find', () => {\n      if (this.active) {\n        this.nextMatch();\n      } else {\n        this.activate();\n      }\n    });\n    recorder.registerCommand(context, 'reverseFind', () => {\n      if (this.active) {\n        this.prevMatch();\n      } else {\n        this.activate();\n      }\n    });\n    vscode.window.onDidChangeActiveTextEditor(() => {\n      this.deactivate();\n    });\n  }\n\n  activate() {\n    this.active = true;\n    vscode.commands.executeCommand('setContext', 'groog.findMode', true);\n    this.findWithArgs();\n  }\n\n  deactivate() {\n    this.active = false;\n    vscode.commands.executeCommand('setContext', 'groog.findMode', false);\n    this.findText = \"\";\n    this.cursorStack.clear();\n    vscode.commands.executeCommand(\"cancelSelection\");\n    vscode.commands.executeCommand(\"closeFindWidget\");\n  }\n\n  findWithArgs() {\n    let txt = this.findText;\n    if (this.findText.length === 0) {\n      txt = \"ENTER\" + \"_TEXT\";\n    }\n    vscode.commands.executeCommand(\"editor.actions.findWithArgs\", {\"searchString\": txt}).then(() => {\n      vscode.commands.executeCommand(\"workbench.action.focusActiveEditorGroup\");\n    }, () => {\n      vscode.commands.executeCommand(\"workbench.action.focusActiveEditorGroup\");\n    }\n    );\n    this.cursorToFront();\n    this.nextMatch();\n  }\n\n  ctrlG() {\n    this.deactivate();\n  }\n\n  textHandler(s: string): boolean {\n    // Enter, shift+enter, ctrl+n, ctrl+p taken care of in package.json\n    this.findText = this.findText.concat(s);\n    this.cursorStack.push();\n    this.findWithArgs();\n    return false;\n  }\n\n  moveHandler(s: string): boolean {\n    this.deactivate();\n    return true;\n  }\n\n  delHandler(s: string): boolean {\n    switch (s) {\n      case \"deleteLeft\":\n        this.findText = this.findText.slice(0, this.findText.length-1);\n        this.cursorStack.popAndSet();\n        this.findWithArgs();\n        break;\n      default:\n        vscode.window.showInformationMessage(\"Unsupported find command: \" + s);\n      }\n    return false;\n  }\n\n  // TODO: do something like error message or deactivate\n  onYank(s: string | undefined) {}\n  alwaysOnYank(): boolean {return false;}\n  onKill(s: string | undefined) {}\n  alwaysOnKill(): boolean {return false;}\n}\n\nclass CursorStack {\n  selections: vscode.Position[];\n\n  constructor() {\n    this.selections = [];\n  }\n\n  push() {\n    let editor = vscode.window.activeTextEditor;\n    if (!editor) {\n      vscode.window.showErrorMessage(\"Couldn't find active editor\");\n      this.selections.push(new vscode.Position(0, 0));\n      return;\n    }\n    this.selections.push(new vscode.Position(editor.selection.start.line, editor.selection.start.character));\n  }\n\n  popAndSet() {\n    let p = this.selections.pop();\n    if (!p) {\n      vscode.window.showErrorMessage(\"Ran out of cursor positions\");\n      return;\n    }\n    let editor = vscode.window.activeTextEditor;\n    if (!editor) {\n      vscode.window.showErrorMessage(\"Undefined editor\");\n      return;\n    }\n    // https://github.com/microsoft/vscode/issues/111#issuecomment-157998910\n    editor.selection = new vscode.Selection(p, p);\n  }\n\n  clear() {\n    this.selections = [];\n  }\n}","import * as vscode from 'vscode';\nimport {Recorder} from './record';\n\nexport class MarkHandler {\n  active: boolean;\n  yanked: string;\n\n  constructor() {\n    this.active = false;\n    this.yanked = \"\";\n  }\n\n  register(context: vscode.ExtensionContext, recorder: Recorder) {\n    recorder.registerCommand(context, 'toggleMarkMode', () => {\n      if (this.active) {\n        this.deactivate();\n      } else {\n        this.activate();\n      }\n    });\n    recorder.registerCommand(context, 'paste', () => {\n      if (this.active) {\n        this.deactivate();\n      }\n\n      vscode.window.activeTextEditor?.edit(editBuilder => {\n        let editor = vscode.window.activeTextEditor;\n        if (!editor) {\n          return;\n        }\n        editBuilder.insert(editor.selection.active, this.yanked);\n      });\n    });\n  }\n\n  activate() {\n    this.active = true;\n    vscode.commands.executeCommand('setContext', 'groog.markMode', true);\n  }\n\n  deactivate() {\n    this.active = false;\n    vscode.commands.executeCommand('setContext', 'groog.markMode', false);\n  }\n\n  ctrlG() {\n    this.deactivate();\n  }\n\n  textHandler(s: string): boolean {\n    this.deactivate();\n    return true;\n  }\n\n  moveHandler(vsCommand: string, ...rest: any[]): boolean {\n    // See below link for cusorMove args (including \"select\" keyword)\n    // https://code.visualstudio.com/api/references/commands\n    if (vsCommand === \"cursorMove\") {\n      rest[0].select = true;\n      vscode.commands.executeCommand(vsCommand, ...rest);\n    } else {\n      vscode.commands.executeCommand(vsCommand + \"Select\", ...rest);\n    }\n    return false;\n  }\n\n  delHandler(s: string): boolean {\n    this.deactivate();\n    return true;\n  }\n\n  onYank(s: string | undefined) {\n    this.deactivate();\n    s ? this.yanked = s : this.yanked = \"\";\n  }\n\n  alwaysOnYank(): boolean {\n    return true;\n  }\n\n  onKill(s: string | undefined) {\n    this.deactivate();\n    s ? this.yanked = s : this.yanked = \"\";\n  }\n\n  alwaysOnKill(): boolean {\n    return true;\n  }\n}","import * as vscode from 'vscode';\n\nexport interface MultiCommand {\n  sequence: string[]\n}\n\nexport function multiCommand(mc: MultiCommand) {\n  for (var command of mc.sequence) {\n    vscode.commands.executeCommand(command);\n  }\n}\n","import * as vscode from 'vscode';\n\nexport class Recorder {\n  private baseCommand: boolean;\n  active: boolean; // aka \"recording\"\n  private recordBook: Record[];\n\n  constructor() {\n    this.baseCommand = true;\n    this.active = false;\n    this.recordBook = [];\n  }\n\n  register(context: vscode.ExtensionContext, recorder: Recorder) {\n    recorder.registerCommand(context, \"record.startRecording\", () => recorder.startRecording());\n    recorder.registerCommand(context, \"record.endRecording\", () => recorder.endRecording());\n    recorder.registerCommand(context, \"record.playRecording\", () => recorder.playback());\n  }\n\n  registerCommand(context: vscode.ExtensionContext, commandName: string, callback: (...args: any[]) => any) {\n    context.subscriptions.push(vscode.commands.registerCommand(\"groog.\" + commandName, (...args: any) => {\n      this.execute(\"groog.\" + commandName, args, callback);\n    }));\n  }\n\n  execute(command: string, args: any[], callback: (...args: any[]) => any): any {\n    if (command.includes(\"groog.record\") || !this.active || !this.baseCommand) {\n      return callback(...args);\n    }\n    this.addRecord(new Record(command, args));\n    this.baseCommand = false;\n    let r = callback(...args);\n    this.baseCommand = true;\n    return r;\n  }\n\n  startRecording() {\n    if (this.active) {\n      vscode.window.showInformationMessage(\"Already recording!\");\n    } else {\n      this.activate();\n      this.recordBook = [];\n      vscode.window.showInformationMessage(\"Recording started!\");\n    }\n  }\n\n  endRecording() {\n    if (!this.active) {\n      vscode.window.showInformationMessage(\"Not recording!\");\n    } else {\n      this.deactivate();\n      vscode.window.showInformationMessage(\"Recording ended!\");\n    }\n  }\n\n  playback() {\n    if (this.active) {\n      vscode.window.showInformationMessage(\"Still recording!\");\n      return;\n    }\n    vscode.window.showInformationMessage(\"Playing recording!\");\n    let sl: string[] = [];\n    for (var record of this.recordBook) {\n      sl.push(record.command);\n      vscode.commands.executeCommand(record.command, ...record.args);\n    }\n  }\n\n  activate() {\n    this.active = true;\n    vscode.commands.executeCommand('setContext', 'groog.recording', true);\n  }\n\n  deactivate() {\n    this.active = false;\n    vscode.commands.executeCommand('setContext', 'groog.recording', false);\n\n  }\n\n  addRecord(r: Record) {\n    this.recordBook = this.recordBook.concat(r);\n  }\n\n  textHandler(s: string): boolean {\n    this.addRecord(new Record(\"type\", [{ \"text\": s}]));\n    return true;\n  }\n  \n  // All these functions are associated with a \"groog.*\" command so these are\n  // already added to the record book via the \"type\" command handling\n  onKill(s: string | undefined) {}\n  alwaysOnKill(): boolean {return false;}\n  ctrlG() {}\n  onYank(s: string | undefined) {}\n  alwaysOnYank(): boolean {return false;}\n  delHandler(s: string): boolean {\n    return true;\n  }\n  moveHandler(vsCommand: string, ...rest: any[]): boolean {\n    return true;\n  }\n}\n\nclass Record {\n  command: string;\n  args: any[];\n\n  constructor(command: string, args: any[]) {\n    this.command = command;\n    this.args = args;\n  }\n}","module.exports = require(\"vscode\");","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// The module 'vscode' contains the VS Code extensibility API\n// Import the module and reference it with the alias vscode in your code below\nimport * as vscode from 'vscode';\nimport {Emacs} from './emacs';\n\nconst groogery = new Emacs();\n\n// this method is called when your extension is activated\n// your extension is activated the very first time the command is executed\nexport function activate(context: vscode.ExtensionContext) {\n  groogery.register(context);\n}\n\n// this method is called when your extension is deactivated\nexport function deactivate() {}\n"],"names":["cursorMoves","ctrlGCommands","deleteCommands","GlobalStateTracker","constructor","key","this","get","context","globalState","update","vt","qmk","recorder","Recorder","typeHandlers","FindHandler","MarkHandler","register","move","m","registerCommand","dc","d","delCommand","th","subscriptions","push","vscode","commands","args","type","jump","fall","toggleQMK","yank","kill","ctrlG","multiCommand","setQMK","runHandlers","thCallback","applyCallback","apply","active","window","activeTextEditor","showInformationMessage","s","text","textHandler","executeCommand","delHandler","bu","b","range","selection","maybe","document","getText","edit","editBuilder","delete","alwaysOnYank","onYank","cmd","editor","startPos","endPos","lineAt","line","end","Range","trim","length","Position","alwaysOnKill","onKill","vsCommand","rest","moveHandler","findText","cursorStack","CursorStack","cursorToFront","start","Selection","nextMatch","prevMatch","activate","onDidChangeActiveTextEditor","deactivate","findWithArgs","clear","txt","then","concat","slice","popAndSet","selections","showErrorMessage","character","p","pop","yanked","insert","select","mc","command","sequence","baseCommand","recordBook","startRecording","endRecording","playback","commandName","callback","execute","includes","addRecord","Record","r","sl","record","module","exports","require","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","__webpack_modules__","groogery","Emacs"],"sourceRoot":""}