{"version":3,"file":"extension.js","mappings":"uIAAA,eACA,QACA,SACA,SACA,QAGa,EAAAA,YAAwB,CACnC,WACA,aACA,aACA,cACA,aACA,YACA,iBACA,kBACA,YACA,gBAQW,EAAAC,eAA2B,CALrB,aACC,cACG,iBACC,mBA+BxB,cAKEC,cAEEC,KAAKC,KAAM,EACXD,KAAKE,SAAW,IAAI,EAAAC,SACpBH,KAAKI,aAAe,CAClB,IAAI,EAAAC,YACJ,IAAI,EAAAC,YACJN,KAAKE,UAITK,SAASC,GACP,IAAK,IAAIC,KAAQ,EAAAZ,YAAa,CAC5B,MAAMa,EAAID,EACVT,KAAKE,SAASS,gBAAgBH,EAASC,GAAM,IAAMT,KAAKS,KAAKC,KAE/D,IAAK,IAAIE,KAAM,EAAAd,eAAgB,CAC7B,MAAMe,EAAID,EACVZ,KAAKE,SAASS,gBAAgBH,EAASK,GAAG,IAAMb,KAAKc,WAAWD,KAelE,IAAK,IAAIE,KAZTP,EAAQQ,cAAcC,KAAKC,EAAOC,SAASR,gBAAgB,QAAQ,IAAIS,KACrEpB,KAAKqB,QAAQD,OAGfpB,KAAKE,SAASS,gBAAgBH,EAAS,QAAQ,IAAMR,KAAKsB,SAC1DtB,KAAKE,SAASS,gBAAgBH,EAAS,QAAQ,IAAMR,KAAKuB,SAE1DvB,KAAKE,SAASS,gBAAgBH,EAAS,aAAa,IAAMR,KAAKwB,cAC/DxB,KAAKE,SAASS,gBAAgBH,EAAS,QAAQ,IAAMR,KAAKyB,SAC1DzB,KAAKE,SAASS,gBAAgBH,EAAS,QAAQ,IAAMR,KAAK0B,SAC1D1B,KAAKE,SAASS,gBAAgBH,EAAS,SAAS,IAAMR,KAAK2B,UAE5C3B,KAAKI,cAClBW,EAAGR,SAASC,EAASR,KAAKE,UAG5BF,KAAKE,SAASS,gBAAgBH,EAAS,uBAAwB,EAAAoB,cAGjEC,YAAYC,EAA0CC,GACpD,IAAIC,GAAQ,EACZ,IAAK,IAAIjB,KAAMf,KAAKI,aACdW,EAAGkB,SACAH,EAAWf,KAIdiB,GAAQ,IAIVA,GACFD,IAIJV,QAAQD,GACDF,EAAOgB,OAAOC,kBACjBjB,EAAOgB,OAAOE,uBAAuB,uBAGvC,IAAIC,EAAKjB,EAAK,GAAekB,KAC7BtC,KAAK6B,aACFd,GAAsCA,EAAGwB,YAAYF,KACtD,KAAOnB,EAAOC,SAASqB,eAAe,kBAAmBpB,MAI7DN,WAAWD,GACTb,KAAK6B,aACFd,GAAsCA,EAAG0B,WAAW5B,KACrD,KAAOK,EAAOC,SAASqB,eAAe3B,MAI1CW,YACMxB,KAAKC,IACPiB,EAAOgB,OAAOE,uBAAuB,iCAErClB,EAAOgB,OAAOE,uBAAuB,+BAEzCpC,KAAKC,KAAOD,KAAKC,IACfiB,EAAOC,SAASqB,eAAe,aAAc,YAAaxC,KAAKC,KAGjEwB,O,UACE,IAAIiB,EAAsC,QAA9B,EAAAxB,EAAOgB,OAAOC,wBAAgB,eAAEQ,UACxCC,EAAsC,QAA9B,EAAA1B,EAAOgB,OAAOC,wBAAgB,eAAEU,SAASC,QAAQJ,GAS7D,IAAK,IAAI3B,KARL6B,IAC4B,QAA9B,EAAA1B,EAAOgB,OAAOC,wBAAgB,SAAEY,MAAKC,IAC/BN,GACFM,EAAYC,OAAOP,OAKV1C,KAAKI,cACdW,EAAGkB,QACLlB,EAAGmC,OAAON,GAKhBjB,QACE,IAAK,IAAIZ,KAAMf,KAAKI,aACdW,EAAGkB,QACLlB,EAAGY,QAGPT,EAAOC,SAASqB,eAAe,mBAC/BtB,EAAOC,SAASqB,eAAe,mBAC/BtB,EAAOC,SAASqB,eAAe,0BAGjCd,O,MACE,IAAIyB,EAASjC,EAAOgB,OAAOC,iBAC3B,IAAKgB,EACH,OAGF,IAAIC,EAAWD,EAAOR,UAAUV,OAC5BoB,EAASF,EAAON,SAASS,OAAOF,EAASG,MAAMb,MAAMc,IACrDd,EAAQ,IAAIxB,EAAOuC,MAAML,EAAUC,GACnCf,EAAOa,EAAON,SAASC,QAAQJ,GAInC,IAAK,IAAI3B,KAHkB,IAAvBuB,EAAKoB,OAAOC,SACdjB,EAAQ,IAAIxB,EAAOuC,MAAML,EAAU,IAAIlC,EAAO0C,SAASR,EAASG,KAAO,EAAG,KAE7DvD,KAAKI,cAClBW,EAAG8C,OAAOvB,GAEkB,QAA9B,EAAApB,EAAOgB,OAAOC,wBAAgB,SAAEY,MAAKC,IACnCA,EAAYC,OAAOP,MAKvBpB,OACEtB,KAAKS,KAAK,aAAc,CAAC,GAAM,KAAM,GAAM,OAAQ,MA/LtC,KAmMfc,OACEvB,KAAKS,KAAK,aAAc,CAAC,GAAM,OAAQ,GAAM,OAAQ,MApMxC,KAuMfA,KAAKqD,KAAsBC,GACzB/D,KAAK6B,aACFd,GAAsCA,EAAGiD,YAAYF,KAAcC,KACpE,KAAO7C,EAAOC,SAASqB,eAAesB,KAAcC,S,oFChN1D,eAGA,oBAKEhE,cACEC,KAAKiC,QAAS,EACdjC,KAAKiE,SAAW,GAChBjE,KAAKkE,YAAc,IAAIC,EAGzBC,gBAEE,IAAIjB,EAASjC,EAAOgB,OAAOC,iBAC3B,GAAIgB,EAAQ,CACV,IAAIC,EAAWD,EAAOR,UAAU0B,MAChClB,EAAOR,UAAY,IAAIzB,EAAOoD,UAAUlB,EAAUA,IAItDmB,YAEErD,EAAOC,SAASqB,eAAe,qCAGjCgC,YACEtD,EAAOC,SAASqB,eAAe,yCAGjCjC,SAASC,EAAkCN,GAEzCA,EAASS,gBAAgBH,EAAS,QAAQ,KACpCR,KAAKiC,OACPjC,KAAKuE,YAELvE,KAAKyE,cAGTvE,EAASS,gBAAgBH,EAAS,eAAe,KAC3CR,KAAKiC,OACPjC,KAAKwE,YAELxE,KAAKyE,cAKXA,WACEzE,KAAKiC,QAAS,EACdf,EAAOC,SAASqB,eAAe,aAAc,kBAAkB,GAC/DxC,KAAK0E,eAGPC,aACE3E,KAAKiC,QAAS,EACdf,EAAOC,SAASqB,eAAe,aAAc,kBAAkB,GAC/DxC,KAAKiE,SAAW,GAChBjE,KAAKkE,YAAYU,QACjB1D,EAAOC,SAASqB,eAAe,mBAC/BtB,EAAOC,SAASqB,eAAe,mBAGjCkC,eAC+B,IAAzB1E,KAAKiE,SAASN,OAChBzC,EAAOC,SAASqB,eAAe,8BAA+B,CAAC,aAAgB,eAE/EtB,EAAOC,SAASqB,eAAe,8BAA+B,CAAC,aAAgBxC,KAAKiE,WAEtF/C,EAAOC,SAASqB,eAAe,2CAC/BxC,KAAKoE,gBACLpE,KAAKuE,YAGP5C,QACE3B,KAAK2E,aAGPpC,YAAYF,GAKV,OAHArC,KAAKiE,SAAWjE,KAAKiE,SAASY,OAAOxC,GACrCrC,KAAKkE,YAAYjD,OACjBjB,KAAK0E,gBACE,EAGTV,YAAY3B,GAEV,OADArC,KAAK2E,cACE,EAGTlC,WAAWJ,GAUT,MARO,eADCA,GAEJrC,KAAKiE,SAAWjE,KAAKiE,SAASa,MAAM,EAAG9E,KAAKiE,SAASN,OAAO,GAC5D3D,KAAKkE,YAAYa,YACjB/E,KAAK0E,gBAGLxD,EAAOgB,OAAOE,uBAAuB,6BAA+BC,IAEjE,EAITa,OAAOb,IACPwB,OAAOxB,MAGT,MAAM8B,EAGJpE,cACEC,KAAKgF,WAAa,GAGpB/D,OACE,IAAIkC,EAASjC,EAAOgB,OAAOC,iBAC3B,IAAKgB,EAGH,OAFAjC,EAAOgB,OAAO+C,iBAAiB,oCAC/BjF,KAAKgF,WAAW/D,KAAK,IAAIC,EAAO0C,SAAS,EAAG,IAG9C5D,KAAKgF,WAAW/D,KAAK,IAAIC,EAAO0C,SAAST,EAAOR,UAAU0B,MAAMd,KAAMJ,EAAOR,UAAU0B,MAAMa,YAG/FH,YACE,IAAII,EAAInF,KAAKgF,WAAWI,MACxB,IAAKD,EAEH,YADAjE,EAAOgB,OAAO+C,iBAAiB,+BAGjC,IAAI9B,EAASjC,EAAOgB,OAAOC,iBACtBgB,EAKLA,EAAOR,UAAY,IAAIzB,EAAOoD,UAAUa,EAAGA,GAJzCjE,EAAOgB,OAAO+C,iBAAiB,oBAOnCL,QACE5E,KAAKgF,WAAa,M,oFChJtB,eAGA,oBAIEjF,cACEC,KAAKiC,QAAS,EACdjC,KAAKqF,OAAS,GAGhB9E,SAASC,EAAkCN,GACzCA,EAASS,gBAAgBH,EAAS,kBAAkB,KAC9CR,KAAKiC,OACPjC,KAAK2E,aAEL3E,KAAKyE,cAGTvE,EAASS,gBAAgBH,EAAS,SAAS,K,MACrCR,KAAKiC,QACPjC,KAAK2E,aAGuB,QAA9B,EAAAzD,EAAOgB,OAAOC,wBAAgB,SAAEY,MAAKC,IACnC,IAAIG,EAASjC,EAAOgB,OAAOC,iBACtBgB,GAGLH,EAAYsC,OAAOnC,EAAOR,UAAUV,OAAQjC,KAAKqF,cAKvDZ,WACEzE,KAAKiC,QAAS,EACdf,EAAOC,SAASqB,eAAe,aAAc,kBAAkB,GAGjEmC,aACE3E,KAAKiC,QAAS,EACdf,EAAOC,SAASqB,eAAe,aAAc,kBAAkB,GAGjEb,QACE3B,KAAK2E,aAGPpC,YAAYF,GAEV,OADArC,KAAK2E,cACE,EAGTX,YAAYF,KAAsBC,GAShC,MANkB,eAAdD,GACFC,EAAK,GAAGwB,QAAS,EACjBrE,EAAOC,SAASqB,eAAesB,KAAcC,IAE7C7C,EAAOC,SAASqB,eAAesB,EAAY,YAAaC,IAEnD,EAGTtB,WAAWJ,GAET,OADArC,KAAK2E,cACE,EAITzB,OAAOb,GACLrC,KAAK2E,aACD3E,KAAKqF,OAAThD,GAAoC,GAGtCwB,OAAOxB,GACLrC,KAAK2E,aACD3E,KAAKqF,OAAThD,GAAoC,M,oFC/ExC,eAMA,wBAA6BmD,GAC3B,IAAK,IAAIC,KAAWD,EAAGE,SACrBxE,EAAOC,SAASqB,eAAeiD,K,gFCRnC,eAEA,iBAKE1F,cACEC,KAAK2F,aAAc,EACnB3F,KAAKiC,QAAS,EACdjC,KAAK4F,WAAa,GAGpBrF,SAASC,EAAkCN,GACzCA,EAASS,gBAAgBH,EAAS,yBAAyB,IAAMN,EAAS2F,mBAC1E3F,EAASS,gBAAgBH,EAAS,uBAAuB,IAAMN,EAAS4F,iBACxE5F,EAASS,gBAAgBH,EAAS,wBAAwB,IAAMN,EAAS6F,aAG3EpF,gBAAgBH,EAAkCwF,EAAqBC,GACrEzF,EAAQQ,cAAcC,KAAKC,EAAOC,SAASR,gBAAgB,SAAWqF,GAAa,IAAI5E,KACrFpB,KAAKkG,QAAQ,SAAWF,EAAa5E,EAAM6E,OAI/CC,QAAQT,EAAiBrE,EAAa6E,GACpC,GAAIR,EAAQU,SAAS,kBAAoBnG,KAAKiC,SAAWjC,KAAK2F,YAC5D,OAAOM,KAAY7E,GAErBpB,KAAKoG,UAAU,IAAIC,EAAOZ,EAASrE,IACnCpB,KAAK2F,aAAc,EACnB,IAAIW,EAAIL,KAAY7E,GAEpB,OADApB,KAAK2F,aAAc,EACZW,EAGTT,iBACM7F,KAAKiC,OACPf,EAAOgB,OAAOE,uBAAuB,uBAErCpC,KAAKyE,WACLzE,KAAK4F,WAAa,GAClB1E,EAAOgB,OAAOE,uBAAuB,uBAIzC0D,eACO9F,KAAKiC,QAGRjC,KAAK2E,aACLzD,EAAOgB,OAAOE,uBAAuB,qBAHrClB,EAAOgB,OAAOE,uBAAuB,kBAOzC2D,WACE,GAAI/F,KAAKiC,OAEP,YADAf,EAAOgB,OAAOE,uBAAuB,oBAGvClB,EAAOgB,OAAOE,uBAAuB,sBACrC,IAAImE,EAAe,GACnB,IAAK,IAAIC,KAAUxG,KAAK4F,WACtBW,EAAGtF,KAAKuF,EAAOf,SACfvE,EAAOC,SAASqB,eAAegE,EAAOf,WAAYe,EAAOpF,MAI7DqD,WACEzE,KAAKiC,QAAS,EACdf,EAAOC,SAASqB,eAAe,aAAc,mBAAmB,GAGlEmC,aACE3E,KAAKiC,QAAS,EACdf,EAAOC,SAASqB,eAAe,aAAc,mBAAmB,GAIlE4D,UAAUE,GACRtG,KAAK4F,WAAa5F,KAAK4F,WAAWf,OAAOyB,GAG3C/D,YAAYF,GAEV,OADArC,KAAKoG,UAAU,IAAIC,EAAO,OAAQ,CAAC,CAAE,KAAQhE,OACtC,EAKTwB,OAAOxB,IACPV,SACAuB,OAAOb,IACPI,WAAWJ,GACT,OAAO,EAET2B,YAAYF,KAAsBC,GAChC,OAAO,IAIX,MAAMsC,EAIJtG,YAAY0F,EAAiBrE,GAC3BpB,KAAKyF,QAAUA,EACfzF,KAAKoB,KAAOA,K,QC3GhBqF,EAAOC,QAAUC,QAAQ,YCCrBC,EAA2B,GAG/B,SAASC,EAAoBC,GAE5B,IAAIC,EAAeH,EAAyBE,GAC5C,QAAqBE,IAAjBD,EACH,OAAOA,EAAaL,QAGrB,IAAID,EAASG,EAAyBE,GAAY,CAGjDJ,QAAS,IAOV,OAHAO,EAAoBH,GAAUL,EAAQA,EAAOC,QAASG,GAG/CJ,EAAOC,Q,uGClBf,MAEMQ,EAAW,IAFjB,OAEqBC,OAIrB,oBAAyB3G,GACvB0G,EAAS3G,SAASC,IAIpB,2B","sources":["../.././src/web/emacs.ts","../.././src/web/find.ts","../.././src/web/mark.ts","../.././src/web/multi-command.ts","../.././src/web/record.ts","../../external commonjs \"vscode\"","../../webpack/bootstrap","../.././src/web/extension.ts"],"sourcesContent":["import * as vscode from 'vscode';\nimport {Recorder} from './record';\nimport {MarkHandler} from './mark';\nimport {FindHandler} from './find';\nimport {multiCommand} from './multi-command';\n\nconst jumpDist = 10;\nexport const cursorMoves: string[] = [\n  \"cursorUp\", \n  \"cursorDown\",\n  \"cursorLeft\",\n  \"cursorRight\",\n  \"cursorHome\",\n  \"cursorEnd\",\n  \"cursorWordLeft\",\n  \"cursorWordRight\",\n  \"cursorTop\",\n  \"cursorBottom\"\n];\n\nconst deleteLeft = \"deleteLeft\";\nconst deleteRight = \"deleteRight\";\nconst deleteWordLeft = \"deleteWordLeft\";\nconst deleteWordRight = \"deleteWordRight\";\n\nexport const deleteCommands: string[] = [\n  deleteLeft,\n  deleteRight,\n  deleteWordLeft,\n  deleteWordRight,\n];\n\ninterface Registerable {\n  register(context: vscode.ExtensionContext, recorder: Recorder): void;\n}\n\ninterface TypeHandler extends Registerable {  \n  active: boolean;\n  activate(): void;\n  deactivate(): void;\n  ctrlG(): void;\n\n  onYank(text: string | undefined): void\n  onKill(text: string | undefined): void\n\n  // Returns whether or not to still send the code\n  textHandler(s: string): boolean;\n  delHandler(cmd: string): boolean;\n  moveHandler(cmd: string, ...rest: any[]): boolean;\n\n  // TODO pasteHandler\n  // TODO escape handler (or just same ctrl g?)\n}\n\nexport class Emacs {\n  private qmk: boolean;\n  recorder: Recorder;\n  typeHandlers: TypeHandler[];\n\n  constructor() {\n    // TODO: store this in persistent storage somewhere\n    this.qmk = false;\n    this.recorder = new Recorder();\n    this.typeHandlers = [\n      new FindHandler(),\n      new MarkHandler(),\n      this.recorder,\n    ];\n  }\n\n  register(context: vscode.ExtensionContext) {\n    for (var move of cursorMoves) {\n      const m = move;\n      this.recorder.registerCommand(context, move, () => this.move(m));\n    }\n    for (var dc of deleteCommands) {\n      const d = dc;\n      this.recorder.registerCommand(context, d, () => this.delCommand(d));\n    }\n\n    context.subscriptions.push(vscode.commands.registerCommand('type', (...args: any[]) => {\n      this.type(...args);\n    }));\n\n    this.recorder.registerCommand(context, 'jump', () => this.jump());\n    this.recorder.registerCommand(context, 'fall', () => this.fall());\n\n    this.recorder.registerCommand(context, 'toggleQMK', () => this.toggleQMK());\n    this.recorder.registerCommand(context, 'yank', () => this.yank());\n    this.recorder.registerCommand(context, 'kill', () => this.kill());\n    this.recorder.registerCommand(context, 'ctrlG', () => this.ctrlG());\n\n    for (var th of this.typeHandlers) {\n      th.register(context, this.recorder);\n    }\n\n    this.recorder.registerCommand(context, \"multiCommand.execute\", multiCommand);\n  }\n\n  runHandlers(thCallback: (th: TypeHandler) => boolean, applyCallback: () => void) {\n    let apply = true;\n    for (var th of this.typeHandlers) {\n      if (th.active) {\n        if (!thCallback(th)) {\n          // Note, we can't do \"apply &&= th.textHandler\" because\n          // if apply is set to false at some point, then later\n          // handlers won't run\n          apply = false;\n        }\n      }\n    }\n    if (apply) {\n      applyCallback();\n    }\n  }\n\n  type(...args: any[]) {\n    if (!vscode.window.activeTextEditor) {\n      vscode.window.showInformationMessage(\"NOT TEXT EDITOR?!?!\");\n\t\t}\n\n    let s = (args[0] as TypeArg).text;\n    this.runHandlers(\n      (th: TypeHandler): boolean => { return th.textHandler(s); },\n      () => {vscode.commands.executeCommand(\"default:type\", ...args);},\n    );\n  }\n\n  delCommand(d: string) {\n    this.runHandlers(\n      (th: TypeHandler): boolean => { return th.delHandler(d); },\n      () => {vscode.commands.executeCommand(d);},\n    );\n  }\n\n  toggleQMK() {\n    if (this.qmk) {\n      vscode.window.showInformationMessage('Basic keyboard mode activated');\n    } else {\n      vscode.window.showInformationMessage('QMK keyboard mode activated');\n    }\n\t\tthis.qmk = !this.qmk;\n    vscode.commands.executeCommand('setContext', 'groog.qmk', this.qmk);\n  }\n\n  yank() {\n    let range = vscode.window.activeTextEditor?.selection;\n    let maybe = vscode.window.activeTextEditor?.document.getText(range);\n    if (maybe) {\n      vscode.window.activeTextEditor?.edit(editBuilder => {\n        if (range) {\n          editBuilder.delete(range);\n        }\n      });\n    }\n\n    for (var th of this.typeHandlers) {\n      if (th.active) {\n        th.onYank(maybe);\n      }\n    }\n  }\n\n  ctrlG() {\n    for (var th of this.typeHandlers) {\n      if (th.active) {\n        th.ctrlG();\n      }\n    }\n    vscode.commands.executeCommand(\"cancelSelection\");\n    vscode.commands.executeCommand(\"closeFindWidget\");\n    vscode.commands.executeCommand(\"removeSecondaryCursors\");\n  }\n\n  kill() {\n    let editor = vscode.window.activeTextEditor;\n    if (!editor) {\n      return;\n    }\n\n    let startPos = editor.selection.active;\n    let endPos = editor.document.lineAt(startPos.line).range.end;\n    let range = new vscode.Range(startPos, endPos);\n    let text = editor.document.getText(range);\n    if (text.trim().length === 0) {\n      range = new vscode.Range(startPos, new vscode.Position(startPos.line + 1, 0));\n    }\n    for (var th of this.typeHandlers) {\n      th.onKill(text);\n    }\n    vscode.window.activeTextEditor?.edit(editBuilder => {\n      editBuilder.delete(range);\n    });\n  }\n\n  // C-l\n  jump() {\n    this.move(\"cursorMove\", {\"to\": \"up\", \"by\": \"line\", \"value\": jumpDist});\n  }\n\n  // C-v\n  fall() {\n    this.move(\"cursorMove\", {\"to\": \"down\", \"by\": \"line\", \"value\": jumpDist});\n  }\n\n  move(vsCommand: string, ...rest: any[]) {\n    this.runHandlers(\n      (th: TypeHandler): boolean => { return th.moveHandler(vsCommand, ...rest); },\n      () => {vscode.commands.executeCommand(vsCommand, ...rest);},\n    );\n  }\n}\n\nclass TypeArg {\n  text: string;\n\n  constructor(text: string) {\n    this.text = \"\";\n  }\n}\n","import * as vscode from 'vscode';\nimport {Recorder} from './record';\n\nexport class FindHandler {\n  active: boolean;\n  findText: string;\n  cursorStack: CursorStack;\n\n  constructor() {\n    this.active = false;\n    this.findText = \"\";\n    this.cursorStack = new CursorStack();\n  }\n\n  cursorToFront() {\n    // Move cursor to beginning of selection\n    let editor = vscode.window.activeTextEditor;\n    if (editor) {\n      let startPos = editor.selection.start;\n      editor.selection = new vscode.Selection(startPos, startPos);\n    }\n  }\n\n  nextMatch() {\n    // Then find next match\n    vscode.commands.executeCommand(\"editor.action.nextMatchFindAction\");\n  }\n\n  prevMatch() {\n    vscode.commands.executeCommand(\"editor.action.previousMatchFindAction\");\n  }\n\n  register(context: vscode.ExtensionContext, recorder: Recorder) {\n    // TODO: cache previous find\n    recorder.registerCommand(context, 'find', () => {\n      if (this.active) {\n        this.nextMatch();\n      } else {\n        this.activate();\n      }\n    });\n    recorder.registerCommand(context, 'reverseFind', () => {\n      if (this.active) {\n        this.prevMatch();\n      } else {\n        this.activate();\n      }\n    });\n  }\n\n  activate() {\n    this.active = true;\n    vscode.commands.executeCommand('setContext', 'groog.findMode', true);\n    this.findWithArgs();\n  }\n\n  deactivate() {\n    this.active = false;\n    vscode.commands.executeCommand('setContext', 'groog.findMode', false);\n    this.findText = \"\";\n    this.cursorStack.clear();\n    vscode.commands.executeCommand(\"cancelSelection\");\n    vscode.commands.executeCommand(\"closeFindWidget\");\n  }\n\n  findWithArgs() {\n    if (this.findText.length === 0) {\n      vscode.commands.executeCommand(\"editor.actions.findWithArgs\", {\"searchString\": \"ENTER\" + \"_TEXT\"});\n    } else {\n      vscode.commands.executeCommand(\"editor.actions.findWithArgs\", {\"searchString\": this.findText});\n    }\n    vscode.commands.executeCommand(\"workbench.action.focusActiveEditorGroup\");\n    this.cursorToFront();\n    this.nextMatch();\n  }\n\n  ctrlG() {\n    this.deactivate();\n  }\n\n  textHandler(s: string): boolean {\n    // Enter, shift+enter, ctrl+n, ctrl+p taken care of in package.json\n    this.findText = this.findText.concat(s);\n    this.cursorStack.push();\n    this.findWithArgs();\n    return false;\n  }\n\n  moveHandler(s: string): boolean {\n    this.deactivate();\n    return true;\n  }\n\n  delHandler(s: string): boolean {\n    switch (s) {\n      case \"deleteLeft\":\n        this.findText = this.findText.slice(0, this.findText.length-1);\n        this.cursorStack.popAndSet();\n        this.findWithArgs();\n        break;\n      default:\n        vscode.window.showInformationMessage(\"Unsupported find command: \" + s);\n      }\n    return false;\n  }\n\n  // TODO: do something like error message or deactivate\n  onYank(s: string | undefined) {}\n  onKill(s: string | undefined) {}\n}\n\nclass CursorStack {\n  selections: vscode.Position[];\n\n  constructor() {\n    this.selections = [];\n  }\n\n  push() {\n    let editor = vscode.window.activeTextEditor;\n    if (!editor) {\n      vscode.window.showErrorMessage(\"Couldn't find active editor\");\n      this.selections.push(new vscode.Position(0, 0));\n      return;\n    }\n    this.selections.push(new vscode.Position(editor.selection.start.line, editor.selection.start.character));\n  }\n\n  popAndSet() {\n    let p = this.selections.pop();\n    if (!p) {\n      vscode.window.showErrorMessage(\"Ran out of cursor positions\");\n      return;\n    }\n    let editor = vscode.window.activeTextEditor;\n    if (!editor) {\n      vscode.window.showErrorMessage(\"Undefined editor\");\n      return;\n    }\n    // https://github.com/microsoft/vscode/issues/111#issuecomment-157998910\n    editor.selection = new vscode.Selection(p, p);\n  }\n\n  clear() {\n    this.selections = [];\n  }\n}","import * as vscode from 'vscode';\nimport {Recorder} from './record';\n\nexport class MarkHandler {\n  active: boolean;\n  yanked: string;\n\n  constructor() {\n    this.active = false;\n    this.yanked = \"\";\n  }\n\n  register(context: vscode.ExtensionContext, recorder: Recorder) {\n    recorder.registerCommand(context, 'toggleMarkMode', () => {\n      if (this.active) {\n        this.deactivate();\n      } else {\n        this.activate();\n      }\n    });\n    recorder.registerCommand(context, 'paste', () => {\n      if (this.active) {\n        this.deactivate();\n      }\n\n      vscode.window.activeTextEditor?.edit(editBuilder => {\n        let editor = vscode.window.activeTextEditor;\n        if (!editor) {\n          return;\n        }\n        editBuilder.insert(editor.selection.active, this.yanked);\n      });\n    });\n  }\n\n  activate() {\n    this.active = true;\n    vscode.commands.executeCommand('setContext', 'groog.markMode', true);\n  }\n\n  deactivate() {\n    this.active = false;\n    vscode.commands.executeCommand('setContext', 'groog.markMode', false);\n  }\n\n  ctrlG() {\n    this.deactivate();\n  }\n\n  textHandler(s: string): boolean {\n    this.deactivate();\n    return true;\n  }\n\n  moveHandler(vsCommand: string, ...rest: any[]): boolean {\n    // See below link for cusorMove args (including \"select\" keyword)\n    // https://code.visualstudio.com/api/references/commands\n    if (vsCommand === \"cursorMove\") {\n      rest[0].select = true;\n      vscode.commands.executeCommand(vsCommand, ...rest);\n    } else {\n      vscode.commands.executeCommand(vsCommand + \"Select\", ...rest);\n    }\n    return false;\n  }\n\n  delHandler(s: string): boolean {\n    this.deactivate();\n    return true;\n  }\n\n  \n  onYank(s: string | undefined) {\n    this.deactivate();\n    s ? this.yanked = s : this.yanked = \"\";\n  }\n\n  onKill(s: string | undefined) {\n    this.deactivate();\n    s ? this.yanked = s : this.yanked = \"\";\n  }\n}","import * as vscode from 'vscode';\n\nexport interface MultiCommand {\n  sequence: string[]\n}\n\nexport function multiCommand(mc: MultiCommand) {\n  for (var command of mc.sequence) {\n    vscode.commands.executeCommand(command);\n  }\n}\n","import * as vscode from 'vscode';\n\nexport class Recorder {\n  private baseCommand: boolean;\n  active: boolean; // aka \"recording\"\n  private recordBook: Record[];\n\n  constructor() {\n    this.baseCommand = true;\n    this.active = false;\n    this.recordBook = [];\n  }\n\n  register(context: vscode.ExtensionContext, recorder: Recorder) {\n    recorder.registerCommand(context, \"record.startRecording\", () => recorder.startRecording());\n    recorder.registerCommand(context, \"record.endRecording\", () => recorder.endRecording());\n    recorder.registerCommand(context, \"record.playRecording\", () => recorder.playback());\n  }\n\n  registerCommand(context: vscode.ExtensionContext, commandName: string, callback: (...args: any[]) => any) {\n    context.subscriptions.push(vscode.commands.registerCommand(\"groog.\" + commandName, (...args: any) => {\n      this.execute(\"groog.\" + commandName, args, callback);\n    }));\n  }\n\n  execute(command: string, args: any[], callback: (...args: any[]) => any): any {\n    if (command.includes(\"groog.record\") || !this.active || !this.baseCommand) {\n      return callback(...args);\n    }\n    this.addRecord(new Record(command, args));\n    this.baseCommand = false;\n    let r = callback(...args);\n    this.baseCommand = true;\n    return r;\n  }\n\n  startRecording() {\n    if (this.active) {\n      vscode.window.showInformationMessage(\"Already recording!\");\n    } else {\n      this.activate();\n      this.recordBook = [];\n      vscode.window.showInformationMessage(\"Recording started!\");\n    }\n  }\n\n  endRecording() {\n    if (!this.active) {\n      vscode.window.showInformationMessage(\"Not recording!\");\n    } else {\n      this.deactivate();\n      vscode.window.showInformationMessage(\"Recording ended!\");\n    }\n  }\n\n  playback() {\n    if (this.active) {\n      vscode.window.showInformationMessage(\"Still recording!\");\n      return;\n    }\n    vscode.window.showInformationMessage(\"Playing recording!\");\n    let sl: string[] = [];\n    for (var record of this.recordBook) {\n      sl.push(record.command);\n      vscode.commands.executeCommand(record.command, ...record.args);\n    }\n  }\n\n  activate() {\n    this.active = true;\n    vscode.commands.executeCommand('setContext', 'groog.recording', true);\n  }\n\n  deactivate() {\n    this.active = false;\n    vscode.commands.executeCommand('setContext', 'groog.recording', false);\n\n  }\n\n  addRecord(r: Record) {\n    this.recordBook = this.recordBook.concat(r);\n  }\n\n  textHandler(s: string): boolean {\n    this.addRecord(new Record(\"type\", [{ \"text\": s}]));\n    return true;\n  }\n  \n  // All these functions are associated with a \"groog.*\" command so these are\n  // already added to the record book via the \"type\" command handling\n  onKill(s: string | undefined) {}\n  ctrlG() {}\n  onYank(s: string | undefined) {}\n  delHandler(s: string): boolean {\n    return true;\n  }\n  moveHandler(vsCommand: string, ...rest: any[]): boolean {\n    return true;\n  }\n}\n\nclass Record {\n  command: string;\n  args: any[];\n\n  constructor(command: string, args: any[]) {\n    this.command = command;\n    this.args = args;\n  }\n}","module.exports = require(\"vscode\");","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// The module 'vscode' contains the VS Code extensibility API\n// Import the module and reference it with the alias vscode in your code below\nimport * as vscode from 'vscode';\nimport {Emacs} from './emacs';\n\nconst groogery = new Emacs();\n\n// this method is called when your extension is activated\n// your extension is activated the very first time the command is executed\nexport function activate(context: vscode.ExtensionContext) {\n  groogery.register(context);\n}\n\n// this method is called when your extension is deactivated\nexport function deactivate() {}\n"],"names":["cursorMoves","deleteCommands","constructor","this","qmk","recorder","Recorder","typeHandlers","FindHandler","MarkHandler","register","context","move","m","registerCommand","dc","d","delCommand","th","subscriptions","push","vscode","commands","args","type","jump","fall","toggleQMK","yank","kill","ctrlG","multiCommand","runHandlers","thCallback","applyCallback","apply","active","window","activeTextEditor","showInformationMessage","s","text","textHandler","executeCommand","delHandler","range","selection","maybe","document","getText","edit","editBuilder","delete","onYank","editor","startPos","endPos","lineAt","line","end","Range","trim","length","Position","onKill","vsCommand","rest","moveHandler","findText","cursorStack","CursorStack","cursorToFront","start","Selection","nextMatch","prevMatch","activate","findWithArgs","deactivate","clear","concat","slice","popAndSet","selections","showErrorMessage","character","p","pop","yanked","insert","select","mc","command","sequence","baseCommand","recordBook","startRecording","endRecording","playback","commandName","callback","execute","includes","addRecord","Record","r","sl","record","module","exports","require","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","__webpack_modules__","groogery","Emacs"],"sourceRoot":""}